import fs from "node:fs";
import path from "node:path";
import { resolveFeature } from "../lib.js";

function readJsonSafe(file) {
  try { return JSON.parse(fs.readFileSync(file, "utf8")); } catch { return null; }
}

/**
 * EVO-012: verify-coverage
 *
 * For each contract file generated by `aitri scaffold`, check that it is
 * referenced (imported/required) in at least one test stub under
 * tests/<feature>/generated/.
 *
 * Detection: looks for the contract file's basename (without extension)
 * inside any test stub's content. This is robust across relative path
 * differences and works for node (import), python (from ... import),
 * and go (import package).
 */
export function checkContractCoverage({ root, manifest }) {
  const contractFiles = manifest.interfaceFiles || [];
  const testFiles = manifest.testFiles || [];

  if (contractFiles.length === 0) {
    return { ok: true, total: 0, covered: 0, uncovered: [] };
  }

  // Read all test stub contents once
  const testContents = testFiles
    .map((f) => {
      const abs = path.join(root, f);
      return fs.existsSync(abs) ? fs.readFileSync(abs, "utf8") : "";
    })
    .join("\n");

  const uncovered = contractFiles.filter((contractPath) => {
    const basename = path.basename(contractPath, path.extname(contractPath));
    return !testContents.includes(basename);
  });

  return {
    ok: uncovered.length === 0,
    total: contractFiles.length,
    covered: contractFiles.length - uncovered.length,
    uncovered
  };
}

export function runVerifyCoverageCommand({
  options,
  getProjectContextOrExit,
  getStatusReportOrExit,
  exitCodes
}) {
  const { OK, ERROR } = exitCodes;
  const project = getProjectContextOrExit();
  const root = process.cwd();

  const jsonOutput = options.json
    || (options.format || "").toLowerCase() === "json"
    || (options.positional || []).some((p) => p.toLowerCase() === "json");

  let feature;
  try {
    feature = resolveFeature(options, getStatusReportOrExit);
  } catch (err) {
    const msg = err instanceof Error ? err.message : "Feature resolution failed.";
    if (jsonOutput) {
      console.log(JSON.stringify({ ok: false, feature: null, issues: [msg] }, null, 2));
    } else {
      console.log(msg);
    }
    return ERROR;
  }

  const manifestFile = path.join(
    project.paths.implementationFeatureDir(feature),
    "scaffold-manifest.json"
  );

  if (!fs.existsSync(manifestFile)) {
    const msg = `Scaffold manifest not found: ${path.relative(root, manifestFile)}\nRun: aitri build --feature ${feature}`;
    if (jsonOutput) {
      console.log(JSON.stringify({ ok: false, feature, issues: [msg] }, null, 2));
    } else {
      console.log(msg);
    }
    return ERROR;
  }

  const manifest = readJsonSafe(manifestFile);
  if (!manifest) {
    const msg = "Scaffold manifest is invalid JSON.";
    if (jsonOutput) {
      console.log(JSON.stringify({ ok: false, feature, issues: [msg] }, null, 2));
    } else {
      console.log(msg);
    }
    return ERROR;
  }

  const result = checkContractCoverage({ root, manifest });

  if (jsonOutput) {
    console.log(JSON.stringify({
      ok: result.ok,
      feature,
      total: result.total,
      covered: result.covered,
      uncovered: result.uncovered
    }, null, 2));
    return result.ok ? OK : ERROR;
  }

  console.log(`Coverage: ${result.covered}/${result.total} contract(s) imported in test stubs`);

  if (!result.ok) {
    console.log("\nUncovered contracts:");
    result.uncovered.forEach((f) => console.log("  " + f));
    console.log("\nFix: ensure each contract file is imported in at least one test stub.");
    console.log(`     Test stubs are in: tests/${feature}/generated/`);
    return ERROR;
  }

  console.log("All contracts are referenced in test stubs.");
  return OK;
}
